// +build ignore

package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type filesFlag []string

func (i *filesFlag) String() string {
	return "service file(s) containing struct"
}

func (i *filesFlag) Set(value string) error {
	*i = append(*i, value)
	return nil
}

var options struct {
	service      string
	serviceFiles filesFlag
	structName   string
	iface        string
	icomment     string
	pkgName      string
	outputFile   string
	comment      string
}

// Prints an error message and exits.
func fatal(msg string, args ...interface{}) {
	msg = fmt.Sprintf(msg, args...)
	fmt.Fprintf(os.Stderr, "error: %s\n", msg)
	os.Exit(1)
}

// Set up flags
func init() {
	flag.StringVar(&options.service, "svc", "", "service name")
	flag.Var(&options.serviceFiles, "sf", "service file(s) containing struct")
	flag.StringVar(&options.structName, "s", "Service", "struct to generate interface from")
	flag.StringVar(&options.iface, "i", "ServicerGenerated", "name of generated interface")
	flag.StringVar(&options.icomment, "ic", "ServicerGenerated represents the interface for implementing all endpoints for this service", "name of generated interface")
	flag.StringVar(&options.pkgName, "p", "", "package name of generated interface")
	flag.StringVar(&options.outputFile, "o", "", "output file name. Print to stdout if not provided")
	flag.Parse()
}

func main() {
	err := filepath.Walk(options.service, visit)
	if err != nil {
		fatal("%v", err)
	}
}

//visit each version directory and generate interfaces
func visit(p string, info os.FileInfo, err error) error {
	if err != nil {
		if strings.Contains(err.Error(), "no such file or directory") {
			fmt.Println("Skipping interface generation for " + p)
		} else {
			return err
		}
	} else if info.IsDir() && info.Name() != options.service {
		generateInterface(info.Name())
	}
	return nil
}

func generateInterface(name string) {
	outFile := filepath.Join(options.service, name, "interface_generated.go")
	args := []string{}
	file := filepath.Join(options.service, name, "service_generated.go")
	fmt.Printf("generating from %s\n", file)
	args = append(args, "-f", file)

	fmt.Print(args)
	args = append(args, "-s", options.structName, "-i", options.iface, "-p", options.pkgName, "--iface-comment", options.icomment, "-c", "Code generated by gen_interface.go. DO NOT EDIT.", "-o", outFile)
	cmd := exec.Command("ifacemaker", args...)
	fmt.Println(cmd)
	_, err := cmd.Output()
	if err != nil {
		fatal("%v", err)
	}

	fmt.Printf("adding license to %s\n", outFile)
	err = addLicense(outFile)

	if err != nil {
		os.Exit(1)
	}

}

func addLicense(filepath string) error {
	licensetxt := []string{
		"/*",
		" * Copyright Â© 2019 Splunk, Inc.",
		" *",
		" * Licensed under the Apache License, Version 2.0 (the \"License\"): you may",
		" * not use this file except in compliance with the License. You may obtain",
		" * a copy of the License at",
		" *",
		" * http://www.apache.org/licenses/LICENSE-2.0",
		" *",
		" * Unless required by applicable law or agreed to in writing, software",
		" * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
		" * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
		" * License for the specific language governing permissions and limitations",
		" * under the License.",
		" */",
		"",
	}

	// read file
	f, err := os.Open(filepath)
	if err != nil {
		fmt.Println(err)
		return err
	}

	var lines []string
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		fmt.Println(err)
		return err
	}

	f.Close()

	// recreate file with license
	file, err := os.OpenFile(filepath, os.O_CREATE|os.O_WRONLY, 0644)

	if err != nil {
		fmt.Println("failed creating file: %s", err)
		return err
	}

	datawriter := bufio.NewWriter(file)

	for _, data := range licensetxt {
		_, _ = datawriter.WriteString(data + "\n")
	}

	for _, data := range lines {
		_, _ = datawriter.WriteString(data + "\n")
	}

	datawriter.Flush()
	file.Close()
	return nil
}
